{
    "collab_server" : "",
    "contents" : "#\n#============== Functions to initialize multiNet\n#\n\n\nstartZ <- function(Y, n, D, K)\n  # Initialize latent positions and distances\n{\n  z <- vapply( 1:K, function(k) {\n    distZ <- sna::geodist(Y[,,k])$gdist\n    distZ[ is.infinite(distZ) ] <- 7^2\n    cmdscale( as.dist(distZ) )\n  }, double(n*D) )\n  # z <- array(z, c(n, D, K))\n  # z <- rowMeans(z, dims = 2)\n  z <- matrix(Rfast::rowmeans(z), ncol = D)\n\n  z <- if ( D == 1 ) z/max(z) else apply(z, 2, function(u) u/max(u) )\n  distZ <- 3 * Rfast::Dist(z, square = TRUE)\n\n  # starting values for muZ and sigmaZ\n  zMeanOld_i <- z\n  zVarOld_i <- if ( D == 1 ) rep(1, n) else matrix(0.1, n, D)\n\n  out <- list( z = z, distZ = distZ, zMeanOld_i = zMeanOld_i, zVarOld_i = zVarOld_i )\n  return(out)\n}\n\n\n\nstartLogit <- function(Y, K, distZ, alpha1)\n  # Initialize logit parameters\n{\n  predZ <- -c(distZ)\n  tmp <- vapply(1:K, function(k) {\n    Rfast::glm_logistic(predZ, c(Y[,,k]))$be[,1]\n  }, double(2) )\n  alpha <- tmp[1,] + 2\n  beta <- tmp[2,]\n  alpha[1] <- alpha1\n  alpha <- ifelse( abs(alpha) > 3, alpha / ( 10^nchar(abs(round(alpha))) ), alpha )\n  beta[2:K] <- beta[2:K] + abs( 1 - beta[1] )\n  beta[1] <- 1\n  # beta <- ifelse(beta < 0, abs(1 - beta[1]), beta )\n  beta <- ifelse(beta < 0, 0, beta )\n\n  # mean and variance paramters\n  muAlpha <- mean(alpha)\n  muBeta <- mean(beta)\n  sigmaAlpha <- var(alpha) + 1\n  sigmaBeta <- var(beta) + 1\n\n  # get starting values for mu_alpha^k and sigma_alpha^k\n  meanAlphaOld_k  <- alpha[2:K]\n  varAlphaOld_k <- rep(1, K)\n\n  # get starting values for mu_beta^k and sigma_beta^k\n  meanBetaOld_k <- beta[2:K]\n  varBetaOld_k <- rep(1, K - 1)\n\n  out <- list(alpha = alpha, muAlpha = muAlpha, sigmaAlpha = sigmaAlpha,\n              meanAlphaOld_k = meanAlphaOld_k, varAlphaOld_k = varAlphaOld_k,\n              beta = beta, muBeta = muBeta, sigmaBeta = sigmaBeta,\n              meanBetaOld_k = meanBetaOld_k, varBetaOld_k = varBetaOld_k)\n  return(out)\n}\n\n\n\nstartSend <- function(Y, arcSumY, n, K, sender, theta0)\n  # Initialize sender parameters\n{\n  if ( is.null(sender) ) {\n    theta <- matrix(1, n,K)\n    return(theta)\n  } else {\n    theta <- switch(sender,\n                    const = {\n                      # varies with n but fixed in K\n                      arcSum <- arcSumY/( n*(n-1) )\n                      tmp1 <- colSums( aperm(sweep(Y, 3, arcSum, \"*\"), c(2,1,3)), na.rm = TRUE )\n                      thetaIni <- sweep(tmp1, 2, Rfast::colMaxs(tmp1), \"/\")\n                      theta <- matrix(rep(Rfast::rowmeans(thetaIni)), n, K)\n                      theta[cbind(1:K, theta0)] <- 0\n                      theta <- ifelse(theta < 0, 0, theta)\n                      theta <- ifelse(theta > 1, 1, theta)\n                    },\n                    var = {\n                      theta <- colSums( aperm(Y, c(2,1,3)), na.rm = TRUE )/(n-1)\n                      theta[cbind(theta0, 1:K)] <- 0\n                      theta <- ifelse(theta < 0, 0, theta)\n                      theta <- ifelse(theta > 1, 1, theta)\n                    }\n    )\n  }\n\n  return(theta)\n}\n\n\n\nstartRec <- function(Y, arcSumY, n, K, receiver, gamma0)\n  # Initialize receiver parameters\n{\n  if ( is.null(receiver) ) {\n    gamma <- matrix(1, n,K)\n    return(gamma)\n  } else {\n    gamma <- switch(receiver,\n                    const = {\n                      arcSum <- arcSumY/( n*(n-1) )\n                      tmp1 <- colSums( sweep(Y, 3, arcSum, \"*\"), na.rm = TRUE )\n                      gammaIni <- sweep(tmp1, 2, Rfast::colMaxs(tmp1), \"/\")\n                      gamma <- matrix(rep(Rfast::rowmeans(gammaIni)), n, K)\n                      gamma[cbind(gamma0, 1:K)] <- 0\n                      gamma <- ifelse(gamma < 0, 0, gamma)\n                      gamma <- ifelse(gamma > 1, 1, gamma)\n                    },\n                    var = {\n                      gamma <- colSums( Y, na.rm = TRUE )/(n-1)\n                      gamma[cbind(gamma0, 1:K)] <- 0\n                      gamma <- ifelse(gamma < 0, 0, gamma)\n                      gamma <- ifelse(gamma > 1, 1, gamma)\n                    }\n    )\n  }\n\n  return(gamma)\n}\n\n\n\nstartLambda <- function(covariates, nC)\n  # Initialize parameter for covariates\n{\n  if ( !is.null(covariates) ) {\n    # nC <- dim(covariates)[3]\n    lambda <- rep(1, nC)\n    lambdaMu <- rep(0, nC)\n    lambdaSigma <- rep(1, nC)\n    return( list(lambda = lambda, lambdaMu = lambdaMu, lambdaSigma = lambdaSigma) )\n  } else {\n    lambda <- 0\n    return( list(lambda = lambda) )\n  }\n}\n\n",
    "created" : 1508527424478.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2800306760",
    "id" : "C7F515B7",
    "lastKnownWriteTime" : 1508527484,
    "last_content_update" : 1508527484543,
    "path" : "~/Dropbox/spaceNet_package/spaceNet/R/initialize.R",
    "project_path" : "R/initialize.R",
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}