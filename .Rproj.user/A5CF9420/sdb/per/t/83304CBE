{
    "collab_server" : "",
    "contents" : "#######################################################################\n#######################################################################\n#####                                                             #####\n##### MCMC for Latent Space Modeling of Multidimensional Networks #####\n#####                                                             #####\n##### The following function estimates all the different variants #####\n##### of the model: GN, GC, GV, TN, TC, TV                        #####\n#####                                                             #####\n#######################################################################\n#######################################################################\n\n\nmultiNet <- function( Y, niter = 1000, D = 2,\n                      nuA, nuB, tauA, tauB, muA, muB,\n                      node.index,\n                      receiver, sender,\n                      controlZ,\n                      ztrue, gamma.0 = 1, theta.0 = 1,\n                      alpha.0 = 1, covariates = 1 )\n{\n\n  # we like arrays\n  if ( is.list(Y) ) Y <- array( unlist(Y), dim = c(dim(Y[[1]]), length(Y)) )\n\n  # constants\n  K <- dim(Y)[3]     # number of views\n  n <- dim(Y)[1]     # number of nodes\n  boundA <- log( (log(n))/(n -log(n)) )   # lower bound for the alphas\n\n\n  ##----- Starting Values----------------------------------------##\n\n  ## Latent positions & distances\n  z.array <- array( rep(NA, n*D*K), dim = c(n, D, K) )\n  for ( k in 1:K ){\n    disz <- sna::geodist(Y[,,k])$gdist  ## starting values for the distances between latent positions\n    distMAXval  <- 57\n    disz[which(disz==Inf)] <- distMAXval\n    disz2 <- as.dist(disz)\n    z1 <- cmdscale(disz2, k = D)\n    z.array[,, k] <- z1         ## starting values for the latent positions\n  }\n  z <- matrix(rep( NA, D*n ), ncol = D)\n  for( i in 1:n ){\n    for ( d in 1:D ){\n      z[i, d] <- mean( z.array[i, d,])\n    }\n  }\n  if( D == 1){z <- z/max(z)}\n  if( D > 1){ z <- apply( z, 2, function(x) x/max(x))}\n\n\n  disz <- as.matrix( dist(z)^2)*3  ## CHECK MODIFICA\n\n  ## Calculate the starting values for mu_zi and sigma_zi\n  if ( D == 1){ z.mean.old <- z\n  z.sigma.old <- rep(1, n)\n  }\n  if ( D > 1){ z.mean.old <- z\n  z.sigma.old <- rep (list(matrix( diag(.1, D), ncol = D)), n)\n  }\n\n  ## Logit parameters\n  alpha <- rep(NA, K)\n  beta <- rep(NA, K)\n  dhatvec <-  -c(disz)\n\n  for ( k in 1:K ){       ## starting values for beta parameters\n    Yvec <- c(Y[,,k])\n    fit <- glm( Yvec ~dhatvec, family = \"binomial\")\n    alpha[k] <- as.numeric( fit$coefficients[1]) +2\n    beta[k] <- as.numeric( fit$coefficients[2])\n  }\n  alpha[1] <- alpha.0\n  alpha[2:K] <- sapply( alpha[2:K], inizia.alpha)\n  beta[2:K] <- beta[2:K] +abs( 1 -beta[1])\n  beta[1] <- 1\n  beta[which( beta<0)] <- abs( 1 -beta[1])\n\n  ## Mean and Variance parameters\n  mu.Alpha <- mean(alpha)\n  mu.Beta <- mean(beta)\n  sigma.Alpha <- var(alpha) +1\n  sigma.Beta  <- var(beta)  +1\n\n  ## Calculate the starting values for mu_alpha^k and sigma_alpha^k\n  alpha.K.mean.old  <- alpha[2:K]\n  alpha.K.sigma.old <- rep(1, K)\n\n  ## Calculate the starting values for mu_beta^k and sigma_beta^k\n  beta.K.mean.old <- beta[2:K]\n  beta.K.sigma.old <- rep(1, K -1)\n\n\n\n\n  #starting values for the receiver parameters and sender parameters\n  if( is.null(receiver)){ gamma <- matrix( rep(1, n*K), ncol = n)}\n  if( is.null(sender)){ theta <- matrix( rep(1, n*K), ncol = n)}\n\n  if( !is.null(sender)){\n    if ( sender == \"const\"){\n      arches.sum<- sapply(1:K, function(x) sum(Y[,,x], na.rm = T))/(n *(n -1))\n      theta.ini <- (sapply(1:K, function(x) rowSums( Y[,,x]*arches.sum[x], na.rm = T)/\n                             max( rowSums(Y[,,x]*arches.sum[x], na.rm =TRUE))) )\n      theta <- matrix(rep(apply(theta.ini,1, mean),K), nrow =K, byrow = T)\n      for( k in 1:K){\n        theta[k, theta.0[k]] <- 0\n      }\n      theta[which(theta<0 )]<-0\n      theta[which(theta>1 )]<-1\n    }\n    if( sender == \"var\"){\n      theta <- t((sapply(1:K, function(x) rowSums( Y[,,x] ,na.rm = T)/(n-1))))\n      theta[which(theta<0 )]<-0\n      theta[which(theta>1 )]<-1\n      for( k in 1:K){\n        theta[k, theta.0[k]] <- 0\n      }\n    }\n  }\n\n  if( !is.null(receiver)){\n    if( receiver == \"const\"){\n      arches.sum<- sapply(1:K, function(x) sum(Y[,,x], na.rm = T))/(n *(n -1))\n      gamma.ini <- (sapply(1:K, function(x) colSums( Y[,,x]*arches.sum[x], na.rm = T)/\n                             max( colSums(Y[,,x]*arches.sum[x], na.rm =TRUE))) )\n      gamma <- matrix( rep(apply(gamma.ini,1, mean), K), nrow=K, byrow = T)\n      gamma[which(gamma<0 )]<-0\n      gamma[which(gamma>1 )]<-1\n      for( k in 1:K){\n        gamma[k, gamma.0[k]] <- 0\n      }\n    }\n    if( receiver == \"var\"){\n      gamma <- t(sapply(1:K, function(x) colSums( Y[,,x], na.rm = T)/(n-1)))\n      gamma[which(gamma<0 )]<-0\n      gamma[which(gamma>1 )]<-1\n      for( k in 1:K){\n        gamma[k, gamma.0[k]] <- 0\n      }\n    }\n  }\n\n  #starting values for lambda and objects for saving\n  if( is.list(covariates)){\n    lenC = length(covariates)\n    lambda <- rep(1, lenC)\n    lambda.mu <- rep(0, lenC)\n    lambda.sd <- rep(1, lenC)\n    Save.Lambda <- matrix(NA, nrow= niter+1, ncol = lenC)\n    Accept.Lambda <- matrix(NA, nrow= niter, ncol = lenC)\n  }\n\n  if( !is.list(covariates)){ lambda <- 0\n  Save.Lambda <- NA\n  Accept.Lambda <- NA\n  }\n\n  ##------Objects to save----------------------------------------##\n\n  ## Saving parameters\n  np.Save <- K -1 +K -1 +4  ## number of parameters to save\n  Save.param <- matrix(rep(NA,(niter+1)*np.Save), ncol =np.Save)  ## matrix where to save simulated values\n  colnames(Save.param) <- c( \"sigmaAlpha\", \"sigmaBeta\", \"muAlpha\",\n                             \"muBeta\", paste(rep(\"alpha\", K -1), seq(2,K,1), sep=\"\"),\n                             paste(rep(\"beta\", K -1), seq(2,K,1), sep=\"\"))\n  Save.param[1, ] <- c( sigma.Alpha, sigma.Beta, mu.Alpha,\n                        mu.Beta, alpha[2:K], beta[2:K]) ## saving the starting values in the first row\n\n  ## Saving latent positions\n  Save.z <- list()\n  Save.z[[1]] <- z         ##saving the starting values in the first element\n\n\n  # Saving gamma parameters and their acceptance probs\n  if( is.null(receiver)){ Save.gamma  = 0\n  Accept.Gamma = 0}\n  if( !is.null(receiver)){ Save.gamma <-list()\n  Accept.Gamma <- list()\n  for( k in 1:K){\n    Save.gamma[[k]] <- matrix(rep(NA, (niter +1)*n), ncol=n)\n    Save.gamma[[k]][1, ] <- gamma[k, ]\n    Accept.Gamma[[k]] <- matrix(rep(NA, niter*n), ncol= n)\n  }\n  }\n\n\n  # Saving theta parameters and their acceptance probs\n  if( is.null(sender)){ Save.theta  = 0\n  Accept.Theta = 0}\n  if( !is.null(sender)){ Save.theta <-list()\n  Accept.Theta <- list()\n  for( k in 1:K){\n    Save.theta[[k]] <- matrix(rep(NA, (niter +1)*n), ncol=n)\n    Save.theta[[k]][1, ] <- theta[k, ]\n    Accept.Theta[[k]] <- matrix(rep(NA, niter*n), ncol= n)\n  }\n  }\n\n  ## Saving when the proposed values for the logit parameters and the zs are accepted (1) and when not (0)\n  Accept.Alpha <- matrix(rep(NA,(K -1)*niter), ncol= K -1)\n  Accept.Beta <- matrix(rep(NA,(K -1)*niter ), ncol = K - 1 )\n  Accept.z <- matrix(rep(NA, niter*n), ncol= n)\n\n  ##control on the lat pos\n  if( controlZ == FALSE){corrz <- 0}\n  if( controlZ == TRUE){corrz <- rep(NA, niter)}\n\n  #################################################################\n  ##------Let's start the MCMC-----------------------------------##\n  #################################################################\n\n  for ( iter in 1:niter ){\n    if( iter/10==round(iter/10)){ print(paste(\"iter=\", iter))}\n\n    ##------Update sigma_alpha-------------------------------------##\n    sigma.Alpha <- sigma.fc(alpha, mu.Alpha, nuA, tauA) ## new value\n    sigma.Alpha <- sigma.Alpha *(n/5)\n    Save.param[iter +1, 1] <- sigma.Alpha  ## saving the new value\n\n    ##------Update sigma_beta--------------------------------------##\n    sigma.Beta <- sigma.fc(beta, mu.Beta, nuB, tauB) ## new value\n    Save.param[iter +1, 2] <- sigma.Beta   ## saving the new value\n\n    ##------Update mu_alpha----------------------------------------##\n    mu.Alpha <- mu.fc(alpha, sigma.Alpha, tauA, boundA, Inf, muA)  ## new value\n    Save.param[iter +1, 3] <- mu.Alpha   ## saving the new value\n\n    ##------Update mu_beta-----------------------------------------##\n    mu.Beta <- mu.fc(beta, sigma.Beta, tauB, 0, Inf, muB) ## proposed new value\n    Save.param[iter +1, 4] <- mu.Beta\n\n    ##------Update alpha^(k) and beta^(k)---------------------------------##\n    alpha.candidate <- alpha.proposal(Y, beta, gamma, theta, disz, mu.Alpha,\n                                      sigma.Alpha, boundA, K, n, node.index,\n                                      lambda, covariates)\n    ## proposed new value for the alphas\n    beta.candidate <- beta.proposal(Y, alpha, gamma, theta, disz, mu.Beta,\n                                    sigma.Beta, K, n, node.index, lambda,\n                                    covariates) ## proposed new value\n\n    alpha.try <- alpha.candidate[[1]]\n    alpha.try.mean <- alpha.candidate[[2]]\n    alpha.try.var <- alpha.candidate[[3]]\n    alpha.old <- alpha  ##saving the current values of the alphas\n    alpha.new <- alpha.old ##vector with new values for alpha\n\n    beta.try <- beta.candidate[[1]]\n    beta.try.mean <- beta.candidate[[2]]\n    beta.try.var <- beta.candidate[[3]]\n    beta.old <- beta  ##saving the current values of the betas\n    beta.new <- beta.old   ##vector with new values for beta\n\n    # accetta.alp.beta = 0\n    for ( k in 2:K ){  # see, sequentially, if the new values jointly for alpha and beta are acc or rej\n      ##new values\n      alpha.new[k] = alpha.try[k -1]\n      beta.new[k] = beta.try[k -1]\n\n      ##log posteriors\n      log.A1.alpha.beta <-   log.posterior(Y, mu.Alpha, mu.Beta, sigma.Alpha, sigma.Beta,\n                                           alpha.new, beta.new, gamma, theta, z, disz,\n                                           tauA, tauB, nuA, nuB, muA, muB, n, K,\n                                           node.index, lambda, covariates) -\n        log.posterior(Y, mu.Alpha, mu.Beta,sigma.Alpha, sigma.Beta,\n                      alpha.old, beta.old, gamma, theta, z, disz, tauA,\n                      tauB, nuA, nuB, muA, muB, n, K, node.index, lambda,\n                      covariates)\n\n      ## proposal\n      pold_new_alpha <- check.log.prob(log(\n        dtruncnorm(alpha.old[k], boundA, Inf, alpha.try.mean[k -1], sqrt(alpha.try.var[k -1]))))\n      pnew_old_alpha <- check.log.prob(log(\n        dtruncnorm(alpha.new[k], boundA, Inf, alpha.K.mean.old[k -1], sqrt(alpha.K.sigma.old[k -1]))))\n      pold_new_beta <- check.log.prob(log(\n        dtruncnorm(beta.old[k], 0, Inf, beta.try.mean[k -1], sqrt( beta.try.var[k -1]))))\n      pnew_old_beta <- check.log.prob(log(\n        dtruncnorm(beta.new[k], 0, Inf, beta.K.mean.old[k -1], sqrt( beta.K.sigma.old[k -1]))))\n\n      log.A2.alpha <- pold_new_alpha -pnew_old_alpha\n      log.A2.beta <- pold_new_beta -pnew_old_beta\n      log.A2.alpha.beta <- check.log.prob(log.A2.beta) +check.log.prob(log.A2.alpha)\n\n      log.A.alpha.beta <- check.log.prob(log.A1.alpha.beta) +\n        check.log.prob(log.A2.alpha.beta)\n\n      log.U <- log (runif(1))\n      if (log.A.alpha.beta >= log.U){ ##accept both alpha and beta new\n        alpha.old[k] <- alpha.new[k]   ##update alphak\n        alpha.K.mean.old[k -1] <- alpha.try.mean[k -1] ##update mean alphak\n        alpha.K.sigma.old[k -1] <- alpha.try.var[k -1] ##update var alphak\n        Accept.Alpha[iter, k -1] <- 1   ##saving that the values proposed is acc\n\n        beta.old[k] <- beta.new[k]   ##update betak\n        beta.K.mean.old[k -1]  <- beta.try.mean[k -1]   ##update mean betak\n        beta.K.sigma.old[k -1] <- beta.try.var[k -1]  ##update var betak\n        Accept.Beta[iter, k -1] <- 1    ## saving that the value prop is acc\n        # accetta.alp.beta = accetta.alp.beta + 1\n      }\n      if (log.A.alpha.beta < log.U){ ##reject both alpha and beta new\n        alpha.new[k] <- alpha.old[k]\n        Accept.Alpha[iter, k -1] <- 0  ##saving that the values proposed is rj\n        beta.new[k] <- beta.old[k]\n        Accept.Beta[iter, k -1] <- 0   ## saving that the value prop is rj\n      }  ##reject\n    }\n    alpha <- alpha.new\n    beta<- beta.new\n\n    Save.param[iter +1, 5:(4 +K -1)] <- alpha[2:K]  ## saving the new values\n    Save.param[iter +1, (5 + K-1):ncol(Save.param)] <- beta[2:K]   ## saving the new values\n\n    ##------Update latent positions--------------------------------##\n    z.old.old <- z\n    z.old <- z  ##saving the current values of the latent pos\n    z.new <- z.old   ##vector with new values for zetas\n    disz.old <- disz\n    disz.old.old <- disz\n\n    for ( i in 1:n){ ##update sequentially the latent positions\n      z.candidate <- z.proposal(alpha, beta, gamma, theta, Y, disz, z.old, i, n,\n                                K, D, node.index, lambda, covariates)\n\n      if (D == 1){ z.new[i] <- z.candidate[[1]]}\n      if (D > 1){ z.new[i, ] <- z.candidate[[1]]}  ## new vector of latent positons prop\n\n      disz.new <- as.matrix(dist(z.new)^2) ## new distances matrix\n\n      log.A1.z <- log.posterior(Y, mu.Alpha, mu.Beta, sigma.Alpha, sigma.Beta,\n                                alpha, beta, gamma, theta, z.new,\n                                disz.new, tauA, tauB, nuA, nuB,muA, muB,\n                                n, K, node.index, lambda, covariates) -\n        log.posterior(Y, mu.Alpha, mu.Beta,sigma.Alpha, sigma.Beta,\n                      alpha, beta, gamma, theta, z.old, disz.old,\n                      tauA, tauB, nuA, nuB, muA, muB, n, K,\n                      node.index, lambda, covariates)\n\n      if(D == 1){\n        pold_new.z <- check.log.prob(log(\n          dnorm(z.old[i], z.candidate[[2]], sqrt(z.candidate[[3]]))))\n        pnew_old.z <- check.log.prob(log(\n          dnorm(z.new[i], z.mean.old[i], sqrt(z.sigma.old[[i]]))))\n      }\n      if(D > 1){\n        pold_new.z <- check.log.prob(log(\n          dmnorm(z.old[i, ], z.candidate[[2]], z.candidate[[3]])))\n        pnew_old.z <- check.log.prob(log(\n          dmnorm(z.new[i, ], z.mean.old[i, ], z.sigma.old[[i]])))\n      }\n\n      log.A2.z <- check.log.prob(pold_new.z) -check.log.prob(pnew_old.z)\n      log.A.z <- check.log.prob(log.A1.z) +log.A2.z\n\n      log.U <- log(runif(1))\n\n      if (log.A.z >= log.U){\n        Accept.z[iter, i  ] <- 1\n        z.old <- z.new   ##updating z\n        disz.old <- disz.new\n        if(D == 1){\n          z.mean.old[i] <- z.candidate[[2]]\n          z.sigma.old[i]<- z.candidate[[3]]\n        }\n        if(D > 1){\n          z.mean.old[i, ] <- z.candidate[[2]]\n          z.sigma.old[[i]] <- z.candidate[[3]]\n        }\n      } ##ok\n      if (log.A.z < log.U){\n        z.new[i, ] <- z.old[i, ]\n        Accept.z[iter, i] <- 0\n      }  ## rej\n    }  ##closing i-loop\n\n    #check if the new set is just a rotation of the previous\n    proc.check <- protest( z.new, z.old.old, scale = F, translation = F)[[6]]\n    if (proc.check >= .95){ z <- z.old.old\n    disz <- disz.old.old\n    }\n    if(proc.check < .95){ z <- z.new\n    disz <- disz.new\n    }\n\n    Save.z[[iter + 1]] <- z\n\n    if (controlZ == TRUE){\n      corrz[iter] <- protest( z, ztrue, scale=F, translation = F)[[6]]\n    }\n\n    ##------Update Receiver Parameters--------------------------------##\n    if( !is.null(receiver)){\n      if( receiver == \"const\"){\n        gamma.new <- sapply( 1:n, function(x) rtruncnorm(1, 0,1, gamma[1, x],.01))\n        gamma.new[gamma.0[1]]<- 0\n        gamma.new <- matrix( rep(gamma.new, K ), nrow = K, byrow = TRUE)\n\n        log.A.ga <- log.posterior(Y, mu.Alpha, mu.Beta,sigma.Alpha, sigma.Beta,\n                                  alpha, beta, gamma.new, theta, z,\n                                  disz, tauA, tauB, nuA, nuB, muA, muB,\n                                  n, K, node.index, lambda, covariates) -\n          log.posterior(Y, mu.Alpha, mu.Beta, sigma.Alpha, sigma.Beta,\n                        alpha, beta, gamma, theta, z, disz,\n                        tauA, tauB, nuA, nuB, muA, muB, n, K,\n                        node.index, lambda, covariates)\n\n        log.U <- log(runif(1))\n\n        if (log.A.ga >= log.U){\n          for( k in 1:K ){\n            Accept.Gamma[[k]][iter, ] <- rep( 1,n)\n            gamma[k, ] <- gamma.new[k, ] ##updating\n            Save.gamma[[k]][iter +1, ] <- gamma[k, ]\n          }\n        } ##ok\n        if (log.A.ga < log.U){\n          for( k in 1:K ){\n            Accept.Gamma[[k]][iter, ] <- rep( 0,n)\n            Save.gamma[[k]][iter +1, ] <- gamma[k, ]\n          }\n        }  ## rej\n      }\n      if( receiver == \"var\"){\n        gamma.new <- gamma\n        for( k in 1:K){\n          gamma.new[k, ] <- sapply( 1:n, function(x) rtruncnorm(1, 0,1, gamma[k, x],.01))\n          gamma.new[gamma.0[k]]<- 0\n\n          log.A.ga <- log.posterior(Y, mu.Alpha, mu.Beta,sigma.Alpha, sigma.Beta,\n                                    alpha, beta, gamma.new, theta, z,\n                                    disz, tauA, tauB, nuA, nuB, muA, muB,\n                                    n, K, node.index, lambda, covariates) -\n            log.posterior(Y, mu.Alpha, mu.Beta, sigma.Alpha, sigma.Beta,\n                          alpha, beta, gamma, theta, z, disz,\n                          tauA, tauB, nuA, nuB, muA, muB, n, K,\n                          node.index, lambda, covariates)\n\n          log.U <- log(runif(1))\n\n          if (log.A.ga >= log.U){\n            Accept.Gamma[[k]][iter, ] <- rep( 1,n)\n            gamma[k, ] <- gamma.new[k, ] ##updating\n            Save.gamma[[k]][iter +1, ] <- gamma[k, ]\n          } ##ok\n          if (log.A.ga < log.U){\n            Accept.Gamma[[k]][iter, ] <- rep( 0,n)\n            Save.gamma[[k]][iter +1, ] <- gamma[k, ]\n\n          }  ##\n\n        }\n      }\n    }\n\n\n    ##------Update Sender Parameters--------------------------------##\n    if( !is.null(sender)){\n      if( sender == \"const\"){\n        theta.new <- sapply( 1:n, function(x) rtruncnorm(1, 0,1, theta[1, x],.01))\n        theta.new[theta.0[1]]<- 0\n        theta.new <- matrix( rep(theta.new, K ), nrow = K, byrow = TRUE)\n\n        log.A.te <- log.posterior(Y, mu.Alpha, mu.Beta,sigma.Alpha, sigma.Beta,\n                                  alpha, beta, gamma, theta.new, z,\n                                  disz, tauA, tauB, nuA, nuB, muA, muB,\n                                  n, K, node.index, lambda, covariates) -\n          log.posterior(Y, mu.Alpha, mu.Beta, sigma.Alpha, sigma.Beta,\n                        alpha, beta, gamma, theta, z, disz,\n                        tauA, tauB, nuA, nuB, muA, muB, n, K,\n                        node.index, lambda, covariates)\n\n        log.U <- log(runif(1))\n\n        if (log.A.te >= log.U){\n          for( k in 1:K ){\n            Accept.Theta[[k]][iter, ] <- rep( 1,n)\n            theta[k, ] <- theta.new[k, ] ##updating\n            Save.theta[[k]][iter +1, ] <- theta[k, ]\n          }\n        } ##ok\n        if (log.A.te < log.U){\n          for( k in 1:K ){\n            Accept.Theta[[k]][iter, ] <- rep( 0,n)\n            Save.theta[[k]][iter +1, ] <- theta[k, ]\n          }\n        }  ## rej\n      }\n      if( sender == \"var\"){\n        theta.new <- theta\n        for( k in 1:K){\n          theta.new[k, ] <- sapply( 1:n, function(x) rtruncnorm(1, 0,1, theta[k, x],.01))\n          theta.new[theta.0[k]]<- 0\n\n          log.A.te <- log.posterior(Y, mu.Alpha, mu.Beta,sigma.Alpha, sigma.Beta,\n                                    alpha, beta, gamma, theta.new, z,\n                                    disz, tauA, tauB, nuA, nuB, muA, muB,\n                                    n, K, node.index, lambda, covariates) -\n            log.posterior(Y, mu.Alpha, mu.Beta, sigma.Alpha, sigma.Beta,\n                          alpha, beta, gamma, theta, z, disz,\n                          tauA, tauB, nuA, nuB, muA, muB, n, K,\n                          node.index, lambda, covariates)\n\n          log.U <- log(runif(1))\n\n          if (log.A.te >= log.U){\n            Accept.Theta[[k]][iter, ] <- rep( 1,n)\n            theta[k, ] <- theta.new[k, ] ##updating\n            Save.theta[[k]][iter +1, ] <- theta[k, ]\n          } ##ok\n          if (log.A.te < log.U){\n            Accept.Theta[[k]][iter, ] <- rep( 0,n)\n            Save.theta[[k]][iter +1, ] <- theta[k, ]\n          }  ##\n        }\n      }\n    }\n\n    ##------Update Covariates Parameters--------------------------------##\n    if( is.list(covariates)){\n\n      lambda.prop <- lambda.proposal(Y, covariates, lambda, alpha, beta, theta, gamma,\n                                     disz, node.index, K, n)\n\n      lambda.new <- lambda.prop$lambda # vector  if lenght(lambda) > 1\n      print(lambda.new)\n      lambda.mu.new <- lambda.prop$mean.prop # vector if lenght(lambda) > 1\n      print(lambda.mu.new)\n      lambda.sd.new <- sqrt(lambda.prop$var.prop )\n      print(lambda.sd.new)\n      for ( lc in 1:lenC){\n        lambda.use = lambda\n        lambda.use[lc] = lambda.new[lc]\n        log.A1.lambda <- log.posterior(Y, mu.Alpha, mu.Beta, sigma.Alpha, sigma.Beta,\n                                       alpha, beta, gamma, theta, z,\n                                       disz, tauA, tauB, nuA, nuB,muA, muB,\n                                       n, K, node.index, lambda.use, covariates) -\n          log.posterior(Y, mu.Alpha, mu.Beta, sigma.Alpha, sigma.Beta,\n                        alpha, beta, gamma, theta, z,\n                        disz, tauA, tauB, nuA, nuB,muA, muB,\n                        n, K, node.index, lambda, covariates)\n\n        pold_new.lambda <- check.log.prob(\n          log(dtruncnorm(lambda[lc], 0,Inf,lambda.mu.new[lc], lambda.sd.new[lc]) ))\n        pnew_old.lambda <- check.log.prob(\n          log(dtruncnorm(lambda.new[lc],0,Inf,lambda.mu[lc], lambda.sd[lc])))\n        log.A.lambda  <- log.A1.lambda +pold_new.lambda -pnew_old.lambda\n\n        log.U <- log(runif(1))\n\n        if (log.A.lambda >= log.U){\n          Accept.Lambda[iter,lc ] <- 1\n          lambda <- lambda.use\n          lambda.mu[lc] <- lambda.mu.new[lc]\n          lambda.sd[lc] <- lambda.sd.new[lc]\n        }\n        ##ok\n        if (log.A.lambda < log.U){\n          Accept.Lambda[iter,lc] <- 0\n        }  ## rej\n        Save.Lambda[iter +1, lc] <- lambda[lc]\n      }\n    }\n  }## closing the niter-loop\n\n  return (list(Y = Y, node.index = node.index, Save.param = Save.param, Save.gamma = Save.gamma,\n               Save.theta = Save.theta, Save.Lambda= Save.Lambda, Save.z = Save.z, Accept.Alpha =Accept.Alpha,\n               Accept.Beta = Accept.Beta, Accept.Gamma = Accept.Gamma, Accept.Theta = Accept.Theta,\n               Accept.Lambda = Accept.Lambda, Accept.z = Accept.z, corrz = corrz ) )\n\n} ##  closing the function\n\n\n\n\n\n",
    "created" : 1508501355572.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2621886117",
    "id" : "83304CBE",
    "lastKnownWriteTime" : 1508416799,
    "last_content_update" : 1508416799,
    "path" : "~/Dropbox/spaceNet_package/main_function.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}