{
    "collab_server" : "",
    "contents" : "##STUFF NEEDED\n\nnode.index.Y <- function(x){\n  for ( i in 1:nrow(x)){\n    for( j in 1:ncol(x)){\n      if (is.na(x[i,j])){x[i,j] <- 0}\n      else{x[i,j] <-1}\n    }\n  }\n  return(x)\n}\n\n\n#5) Initialize alpha parameters\ninizia.alpha <- function( x ){\n  if(  x < -3 | x > 3 ){ out = x / ( 10 ^ ( nchar( abs( round( x ) ) )  ) ) }\n  else{ out = x }\n  return( out )\n}\n\n#6) Check log probabilities\ncheck.log.prob <- function(x){\n  if( is.na(x) ){ x <-  log( .000001) }\n  if( is.infinite(x) ){\n    if( sign(x) == 1 ){ x <- .0001}\n    if( sign(x) == -1 ){  x <- log( .000001) }\n  }\n  return( x )\n}\n\n#7) Check if covariance matrix are positive definite\nadjst.sigma <- function(matr){\n  cdm <- det(matr)\n  pdm <- is.positive.definite(matr)\n  while ( cdm <= 0 | pdm == FALSE ){\n    matr <- matr +diag(ncol(matr))*0.01\n    cdm <- det(matr)\n    pdm <- is.positive.definite(matr)\n  }\n  return(matr)\n}\n\n#8) Create ausiliary variable\ncreate.aus <- function( arg ){\n  out <- sign( arg )\n  if ( is.na(out) ){ out <- 0 }\n  if ( out == -1){ out <- 0 }\n  return( out )\n}\n\n\n###___Function to compute the log posterior___###\n\n#9) Model Log Posterior\nlog.posterior <- function( Y, mualpha, mubeta, sigmaA, sigmaB, alpha, beta, gamma,\n                           theta, z, disz, tauA, tauB, nuA, nuB, muA, muB, n, K,\n                           node.index, lambda, covariates){\n\n  out1 <-  -0.5 *sum( z^2 )  ## latent positions prior\n  #list of covariates\n  outc <-  sum(sapply( 1:length(lambda), function(x) -0.5 *(lambda[x]^2 ) ) )\n\n  out2.1 <- rep ( 0 , K )\n  for( k in 1:K){\n    a<- sapply( gamma[k, ], function(x) x*theta[k, ])\n    diag( a) <- 0\n    cov.list = lapply(1:length(lambda), function(x) lambda[x]*covariates[[x]])\n    arg1 <- alpha[k]*a -beta[k]*disz -cov.list[[1]]\n    if(length(lambda) > 1){\n      for ( lc in 2:length(lambda)){\n        arg1 <- arg1 -cov.list[[lc]]\n      }\n    }\n    diag(arg1) = 0\n    part1 <- Y[[k]] * arg1\n    diag(part1) <- 0\n    part2 <- (- log( 1 +exp( arg1) ))* node.index[[k]]\n    diag(part2) <- 0  ## so we don't include loops\n    logit.part <- sum( part1 +part2, na.rm = T )\n    beta.pr <- -0.5*( ( ( beta[k] -mubeta)^2 )/sigmaB )\n    alpha.pr <- -0.5*( ( ( alpha[k] -mualpha)^2 )/sigmaA )\n\n    out2.1[ k ] <- logit.part +beta.pr +alpha.pr\n  }\n\n  out2 <- sum( out2.1 )\n\n  out3 <- -0.5 *( K*( log(sigmaA) +log(sigmaB)) +\n                    log( tauB*sigmaB ) + log( tauA*sigmaA ) +\n                    (( mubeta -muB)^2)/( tauB* sigmaB)  +((mualpha -muA)^2)/(tauA*sigmaA) +\n                    (1/sigmaA) +(1/sigmaB)  )\n\n  out4 <- (-( nuB/2)- 1)*log(sigmaB) +(-(nuA/2) -1)*log(sigmaA)\n\n  out <- +out1 +out2 +out3 +out4 +outc\n  return(out)\n}\n\n\n#9bis) Model Log likelihood\nlog.likel <- function( Y, mualpha, mubeta, sigmaA, sigmaB, alpha, beta, gamma,\n                       theta, z, disz, tauA, tauB, nuA, nuB, muA, muB, n, K,\n                       node.index, lambda, covariates){\n\n\n  out2.1 <- rep ( 0 , K )\n  for( k in 1:K){\n    a<- sapply( gamma[k, ], function(x) x*theta[k, ])\n    diag( a) <- 0\n    cov.list = lapply(1:length(lambda), function(x) lambda[x]*covariates[[x]])\n    arg1 <- alpha[k]*a -beta[k]*disz -cov.list[[1]]\n    if(length(lambda) > 1){\n      for ( lc in 2:length(lambda)){\n        arg1 <- arg1 -cov.list[[lc]]\n      }\n    }\n    diag(arg1) = 0\n    part1 <- Y[[k]] * arg1\n    diag(part1) <- 0\n    part2 <- (- log( 1 +exp( arg1) ))* node.index[[k]]\n    diag(part2) <- 0  ## so we don't include loops\n    logit.part <- sum( part1 +part2, na.rm = T )\n    beta.pr <- -0.5*( ( ( beta[k] -mubeta)^2 )/sigmaB )\n    alpha.pr <- -0.5*( ( ( alpha[k] -mualpha)^2 )/sigmaA )\n\n    out2.1[ k ] <- logit.part +beta.pr +alpha.pr\n  }\n\n  out2 <- sum( out2.1 )\n\n  out <- +out2\n  return(out)\n}\n\n\n\n###___Full Conditionals___###\n\n#10) Full conditional for the variance parameters\nsigma.fc <- function( par, mu, iperpar1, iperpar2 ){\n  nn <- length(par)\n  p1 <- ( iperpar1 + nn + 1 ) / 2\n  p2 <- ( iperpar2 * ( 1 + sum( ( par - mu )^2 ) ) + ( mu^2 ) ) / ( 2 * iperpar2 )\n  sigma.new <- 1 / rgamma( 1, shape = p1, scale = p2 )\n  return( sigma.new )\n}\n\n#11) Full conditional for the mean parameters\nmu.fc <- function( par, sigma, iperpar, lb, ub, mu ){\n  nn <- length(par)\n  mu.mean <- ( iperpar * sum( par ) + mu ) / ( 1 + iperpar * nn )\n  mu.sd <- sqrt( ( iperpar * sigma ) / ( 1 + iperpar * nn ) )\n  mu.new <- rtruncnorm( 1, a = lb, b = ub, mu.mean, mu.sd )\n  return( mu.new )\n}\n\n###___Full Conditionals___###\n\n#12) Latent Position Proposal\nz.proposal <- function( alpha, beta, gamma, theta, Y, disz, z, i, n, K,D, node.index,\n                        lambda, covariates){   ##one row at a time\n  diff.Y.W <- rep( list( disz[i,]), K) ##nK\n  Sigma.p <-  diag( rep( 1 , D) ) ## Prior cov\n  sigma.i.vec  <- rep ( 0 , K)\n\n  if ( D == 1 ){ mu.i.mat <- rep( 0, K ) }    ## 1-dim z\n  if ( D >  1 ){ mu.i.mat <- matrix( rep( 0, D * K), ncol = D ) }\n\n  for ( k in 1 : K ){  ## creating Y - W matrices , one for each network view\n    cost1 <- sapply( alpha/beta, function(x) x*gamma[k,]*theta[k, i] )\n    if( !is.list(covariates)){ cost2 = 0}\n    if( is.list(covariates)){\n      cost2 = sapply( beta, function(x) +lambda[1]*covariates[[1]][i,]/x)\n      if( length(covariates)>1){\n        for ( lc in 2:length(covariates)){\n          cost2 <- cost2 + sapply( beta, function(x) +lambda[lc]*covariates[[lc]][i,]/x)\n        }\n      }\n    }\n    cost <- cost1 -cost2\n    cost[is.na( cost )] <- 0\n    W.mat.k <- as.numeric( disz[i, ] < cost[,k] )\n    W.mat.k[i] <- 0\n    diff.Y.W[[k]] <- Y[[k]][i, ] -W.mat.k     ## Y - W matrices\n\n    if ( D == 1 ){ mu.i.mat[k] <- beta[k]*sum( c(diff.Y.W[[k]]*z*node.index[[k]][i,], na.rm = T ))}\n    if ( D  > 1 ){ mu.i.mat[k,] <- beta[k]*colSums( z*c(diff.Y.W[[k]]*node.index[[k]][i,] ),na.rm = T )}\n    sigma.i.vec[k] <- beta[k]*sum(abs(diff.Y.W[[k]]*node.index[[k]][i,] ),na.rm = T)\n  }\n\n  sigma.i <-( 1 +2*sum(sigma.i.vec*theta[i]))^(-1)*Sigma.p  ## variance for the i-th proposal\n\n  if ( D == 1 ){ mu.i <- c( sigma.i*2*sum(mu.i.mat)*theta[i] )}\n  if ( D >  1 ){ mu.i <- c( sigma.i %*% (2*colSums(mu.i.mat))*theta[i])}\n\n  if ( D == 1 ){\n    inflaziona <-  sigma.i +.3\n    z.new <- rnorm( 1, mu.i, sqrt(inflaziona)) }\n  if ( D  > 1 ){\n    inflaziona <- sigma.i +Sigma.p*(n/100)\n    z.new <- mvrnorm( 1, mu.i, inflaziona)}\n\n  return( list ( z.new = z.new, mu.i = mu.i, sigma.i = inflaziona))\n}\n\n#13) Update intercept parameters\nalpha.proposal <- function( Y, beta, gamma, theta, disz, mu, sigma, lb, K, n, node.index,\n                            lambda, covariates){\n\n  alpha.new <- rep(NA, K-1)\n  mean.alpha.new <- rep(NA, K-1)\n  var.alpha.new <- rep(NA, K-1)\n\n  for ( k in 2:K){\n    a<- sapply( gamma[,k], function(x) x*theta[,k])\n    diag( a) <-0\n    cov.list = lapply(1:length(lambda), function(x) lambda[x]*covariates[,,x])\n    arg <-mu*a -beta[k]*disz -cov.list[[1]]\n    if(length(lambda) > 1){\n      for ( lc in 2:length(lambda)){\n        arg <- arg -cov.list[[lc]]\n      }\n    }\n    diag(arg) = 0\n    E <- sum ( Y[[k]]*a, na.rm = T)\n    m1 <- #node.index[[k]] *\n      exp(arg)/((1 +exp(arg))^2)*(a^2)\n    diag(m1) <- 0\n    m2 <- #node.index[[k]] *\n      exp(arg)/(1 +exp(arg))*a\n    diag(m2)  <- 0\n\n    var.alpha.new.k <- (sum(m1) +(1/sigma))^(-1)\n    mean.alpha.new.k <- var.alpha.new.k *(E -sum(m2)) +mu\n    var.alpha.new.k <- var.alpha.new.k +(n/200)\n    alpha.new[k-1] <- rtruncnorm( 1, a = lb, b= Inf, mean.alpha.new.k, sqrt(var.alpha.new.k) )\n    mean.alpha.new[k-1] <- mean.alpha.new.k\n    var.alpha.new[k-1] <- var.alpha.new.k\n  }\n\n  return( list( alpha.new = alpha.new, mean.alpha.new = mean.alpha.new, var.alpha.new = var.alpha.new ) )\n}\n\n#14) Update beta parameters\nbeta.proposal <- function( Y, alpha, gamma, theta, disz, mu, sigma, K, n, node.index,\n                           lambda, covariates){\n\n  beta.new <- rep( NA, K-1)\n  mean.beta.new <- rep( NA, K-1)\n  var.beta.new <- rep( NA, K-1)\n\n  for ( k in 2:K ){\n    a<- sapply( gamma[k, ], function(x) x*theta[k, ])\n    diag(a) <- 0\n    cov.list = lapply(1:length(lambda), function(x) lambda[x]*covariates[[x]])\n    arg <-alpha[k]*a -mu*disz -cov.list[[1]]\n    if(length(lambda) > 1){\n      for ( lc in 2:length(lambda)){\n        arg <- arg -cov.list[[lc]]\n      }\n    }\n    diag(arg) = 0\n    var.p1 <- node.index[[k]]*((disz)^(2) *exp(arg))/((1 +exp(arg))^2)\n    diag(var.p1) <- 0\n    var.beta.new.k <- (sum(var.p1) +(1/sigma))^(-1)\n    mu.beta.p1 <- node.index[[k]] *(-disz *Y[[ k ]])  +(( disz *exp(arg))/(1 +exp(arg)))\n    diag(mu.beta.p1) <- 0\n\n    mean.beta.new.k <- var.beta.new.k *(sum( mu.beta.p1, na.rm = T )) +mu\n    var.beta.new.k <- var.beta.new.k +(n/200)\n\n    beta.new[k -1] <- rtruncnorm( 1, a = 0, b = Inf, mean.beta.new.k, sqrt(var.beta.new.k))\n    mean.beta.new[k -1] <- mean.beta.new.k\n    var.beta.new[k -1] <- var.beta.new.k\n  }\n\n  return( list( beta.new = beta.new, mean.beta.new = mean.beta.new, var.beta.new = var.beta.new ))\n}\n\n#15) Update coavriates coefficients, parallely\nlambda.proposal <- function(Y, covariates, lambda, alpha, beta, theta, gamma,\n                            disz, node.index, K, n){\n  mu.lambda = rep( NA, length(lambda))\n  sigma.lambda = rep( NA, length(lambda))\n  for ( lc in 1:length(lambda)){\n    segna <-rep(NA, K)\n    segna2 <-rep(NA, K)\n    for( k in 1:K){\n      part1 <-  -Y[[k]]*covariates[[lc]]\n      a <- sapply( gamma[k,], function(x) x*theta[k,])\n      if( length(lambda) > 1){\n        other.cov = matrix( rowSums(sapply( seq(1, length(lambda))[-lc],\n                                            function(x) lambda[x]*covariates[[x]] )), ncol =n)\n      }\n      if(length(lambda) == 1){other.cov = 0}\n      arg <- (alpha[k]*a -beta[k]*disz -other.cov)*node.index[[k]]\n      arg2 = exp(arg)/(1+exp(arg)) *covariates[[lc]]\n      diag(arg2) = 0\n      segna[k] <- sum(arg2 +part1, na.rm = TRUE)\n      arg3 = exp(arg)/((1+exp(arg))^2) *covariates[[lc]]^2\n      segna2[k] = sum(arg3, na.rm = TRUE)\n    }\n    sigma = (sum(segna2) +1)^(-1)\n    mu.lambda[lc] <- sum(segna)* sigma\n    sigma.lambda[lc] = sigma\n  }\n  lambda.prop <-sapply( 1:length(lambda), function(x) rtruncnorm(1, 0, Inf, mu.lambda[x], sigma.lambda[x]) )\n  return( list(lambda.prop = lambda.prop, mean.prop =mu.lambda, var.prop = sigma.lambda))\n}\n\n\n\n\n\n\n\n",
    "created" : 1508509233959.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "30047072",
    "id" : "D388539E",
    "lastKnownWriteTime" : 1508521256,
    "last_content_update" : 1508521256977,
    "path" : "~/Dropbox/spaceNet_package/utility_functions.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}