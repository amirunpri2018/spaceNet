{
    "collab_server" : "",
    "contents" : "#######################################################################\n#######################################################################\n#####                                                             #####\n##### MCMC for Latent Space Modeling of Multidimensional Networks #####\n#####                                                             #####\n##### The following function estimates all the different variants #####\n##### of the model: GN, GC, GV, TN, TC, TV                        #####\n#####                                                             #####\n#######################################################################\n#######################################################################\n\nlibrary(spaceNet)\nY <- highTechNet\nsender = c(\"const\", \"var\")\nreceiver = c(\"const\", \"var\")\nD = 2\nniter = 100\nmuA = 0\nmuB = 0\ntauA = NULL\ntauB = NULL\nnuA = 3\nnuB = 3\nalpha1 = 0\n# # covariates = NULL\ncovariates <- array(sample(1:100, replace = TRUE), c(21,21,2))/10\nnodInd <- 1\n\n\n\nmultiNet <- function( Y, niter = 1000, D = 2,\n                      muA = 0, muB = 0, tauA = NULL, tauB = NULL, nuA = 3, nuB = 3,\n                      alpha1 = 0,\n                      sender = c(\"const\", \"var\"), receiver = c(\"const\", \"var\"),\n                      covariates = NULL,\n                      burnIn = round(niter/3), trace = TRUE, allChains = FALSE,\n                      zTrue = NULL,\n                      node.index )\n{\n\n  # we like arrays\n  if ( is.list(Y) ) Y <- array( unlist(Y), dim = c(dim(Y[[1]]), length(Y)) )\n  if ( !is.null(covariates) ) {\n    if ( is.list(covariates) ) {\n      covariates <- array( unlist(covariates), dim = c(dim(covariates[[1]]), length(covariates)) )\n    }\n  } else covariates <- 0\n\n  # constants\n  K <- dim(Y)[3]     # number of views\n  n <- dim(Y)[1]     # number of nodes\n  nn <- n*n\n  boundA <- log( (log(n))/(n -log(n)) )   # lower bound for the alphas\n  nC <- dim(covariates)[3]     # number of covariates, if any, else NULL\n  p <- seq(nC)\n\n  # tau hyperparameters\n  if ( is.null(tauA) ) tauA <- (K-1)/K\n  if ( is.null(tauB) ) tauB <- (K-1)/K\n\n  # sender/receiver\n  if ( length(sender) == 2 ) sender <- NULL\n  if ( length(receiver) == 2 ) receiver <- NULL\n  if ( !is.null(sender) ) {\n    sender <- match.arg(sender, c(\"const\", \"var\"))\n    theta0 <- Rfast::colMins( colSums(aperm(Y, c(2,1,3)), na.rm = TRUE) )\n  } else theta0 <- NULL\n  if ( !is.null(receiver) ) {\n    receiver <- match.arg(receiver, c(\"const\", \"var\"))\n    gamma0 <- Rfast::colMins( colSums(Y, na.rm = TRUE) )\n  } else gamma0 <- NULL\n  noSendRec <- is.null(sender) & is.null(receiver)\n\n  # number of arcs for each view\n  arcSumY <- vapply( 1:K, function(k) sum(Y[,,k], na.rm = TRUE), double(1) )\n\n\n  # starting values -------------------------------------------------------------------\n  inZ <- startZ(Y, n, D, K)\n  inLogit <- startLogit(Y, K, inZ$distZ, alpha1)\n  theta <- startSend(Y, arcSumY, n, K, sender, theta0)\n  gamma <- startRec(Y, arcSumY, n, K, receiver, gamma0)\n  inLambda <- startLambda(covariates, nC)\n\n\n  # objects to be stored --------------------------------------------------------------\n  # nPar <- K - 1 + K - 1 + 4       # number of logit parameters\n  ALPHA <- BETA <- accALPHA <- accBETA <- matrix(NA, niter + 1, K - 1)\n  MSALPHA <- MSBETA <- accMSALPHA <- accMSBETA <-\n    matrix(NA, niter + 1, 2)   # muAlpha and sigmaAlpha - muBeta and sigmaBeta\n  ALPHA[1,] <- inLogit$alpha[2:K]\n  BETA[1,] <- inLogit$beta[2:K]\n  MSALPHA[1,] <- c(inLogit$muAlpha, inLogit$sigmaAlpha)\n  MSBETA[1,] <- c(inLogit$muBeta, inLogit$sigmaBeta)\n\n  Z <- array(NA, c(n, D, niter + 1))\n  Z[,,1] <- inZ$z\n  accZ <- matrix(NA, n, niter + 1)\n\n  if ( !is.null(sender) ) {\n    THETA <- accTHETA <- array(NA, c(n, K, niter + 1))\n    THETA[,,1] <- theta\n  }\n  if ( !is.null(receiver) ) {\n    GAMMA <- accGAMMA <- array(NA, c(n, K, niter + 1))\n    GAMMA[,,1] <- gamma\n  }\n\n  if ( !is.null(covariates) ) {\n    nC <- dim(covariates)[3]\n    LAMBDA <- accLAMBDA <- matrix(NA, niter + 1, nC)\n  }\n\n  corrZ <- if ( !is.null(zTrue) ) rep(NA, niter) else NULL\n\n\n  # MCMC ------------------------------------------------------------------------------\n  alpha <- inLogit$alpha[1:K]\n  beta <- inLogit$beta[1:K]\n  muAlpha <- inLogit$muAlpha\n  muBeta <- inLogit$muBeta\n  sigmaAlpha <- inLogit$sigmaAlpha\n  sigmaBeta <- inLogit$sigmaBeta\n  distZ <- inZ$distZ\n  z <- inZ$z\n  lambda <- inLambda$lambda\n\n  for ( it in 2:niter ) {\n    if ( it%%10 == 0 ) showTrace(it)\n\n    if ( !is.null(covariates) ) {    # lambda times covariates\n      lambdaCov <- covariates * array( rep(lambda, each = n*n), c(n, n, nC) )\n      # faster than lambdaCovSum <- apply(lambdaCov, 1:2, sum)\n      tmp1 <- c(lambdaCov)\n      tmp2 <- paste0(\"tmp1[\", (p-1)*(nn) + 1, \":\", p*nn, \"]\", collapse = \"+\")\n      lambdaCovSum <- matrix( eval(parse(text = tmp2)), n,n )\n    } else {\n      lambdaCov <- NULL\n      lambdaCovSum <- 0\n    }\n\n    ### alpha and beta parameters....................................\n    # update sigmaAlpha\n    sigmaAlpha <- sigmaFc(alpha, muAlpha, nuA, tauA) * (n/5)\n    MSALPHA[it,2] <- sigmaAlpha\n\n    # update sigmaBeta\n    sigmaBeta <- sigmaFc(beta, muBeta, nuB, tauB)\n    MSBETA[it,2] <- sigmaBeta\n\n    # update muAlpha\n    muAlpha <- muFc(alpha, sigmaAlpha, tauA, muA, boundA, Inf)\n    MSALPHA[it,1] <- muAlpha\n\n    # update muBeta\n    muBeta <- muFc(beta, sigmaBeta, tauB, muB, 0, Inf)\n    MSBETA[it,1] <- muBeta\n\n    # update alpha\n    alphaBetaCand <-\n      lapply( 2:K, function(k) {\n      alphaBetaProp_k(k, Y[,,k], n, arcSumY[k], alpha[k], beta[k], gamma[,k], theta[,k], distZ,\n                      muAlpha, sigmaAlpha, muBeta, sigmaBeta, boundA, lambdaCovSum, nC, nodInd, noSendRec)\n    } )\n\n\n    ###..............................................................\n\n\n  } # mcmc loop\n\n\n\n}\n\n\n",
    "created" : 1508497694813.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2520740495",
    "id" : "EFCE8BF3",
    "lastKnownWriteTime" : 1508627546,
    "last_content_update" : 1508627546,
    "path" : "~/Dropbox/spaceNet_package/spaceNet/R/multiNet.R",
    "project_path" : "R/multiNet.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}