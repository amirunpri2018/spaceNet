{
    "collab_server" : "",
    "contents" : "#\n#=========== MCMC for Latent Space Modeling of Multidimensional Networks\n#\n\nmultiNet <- function( Y, niter = 1000, D = 2,\n                      muA = 0, tauA = NULL, nuA = 3,\n                      muB = 0, tauB = NULL, nuB = 3,\n                      muL = 0, tauL = NULL, nuL = 3,\n                      alphaRef = 0.1,\n                      # sender = c(\"const\", \"var\"), receiver = c(\"const\", \"var\"),\n                      covariates = NULL, DIC = FALSE,\n                      burnIn = round(niter*0.3), trace = TRUE, allChains = FALSE,\n                      refSpace = NULL )\n{\n  call <- match.call()\n\n  # we like arrays\n  if ( is.list(Y) ) Y <- list2array(Y)\n  if ( !is.null(covariates) ) {\n    if ( is.matrix(covariates) ){ covariates <- list(covariates)}\n    if ( is.list(covariates) ) {\n      covariates <- list2array(covariates)\n    }\n  }\n  # no sender and receiver\n  sender <- receiver <- NULL     # no sender and receiver for v1\n  noSendRec <- is.null(sender) & is.null(receiver)\n\n  # constants\n  K <- dim(Y)[3]     # number of views\n  n <- dim(Y)[1]     # number of nodes\n  nn <- n*n\n  # maximum correlation for 2 subsequential updates of the sender/receiver parameters\n  boundGammaTheta <- 0.975\n  boundA <- if ( noSendRec ) log( (log(n))/(n -log(n)) ) else 0   # lower bound for the alphas\n  nC <- dim(covariates)[3]     # number of covariates, if any, else NULL\n  if( !is.null(nC) ) {\n    p <- if ( is.na(nC) ) 1 else seq(nC)\n    if( is.na(nC) ) nC <- 1\n  }\n\n  # create indicator variable\n  ind <- !is.na(Y)\n\n  # store dBar values for DIC\n  if( DIC ){\n    dBar <- rep(NA, niter)\n  }\n\n  # tau hyperparameters\n  if ( is.null(tauA) ) tauA <- (K-1)/K\n  if ( is.null(tauB) ) tauB <- (K-1)/K\n  if ( is.null(tauL) | !is.null(covariates) ){\n    if ( is.null(nC) ) tauL <- 0.5\n    if ( !is.null(nC) ){\n      tauL <- (nC-1)/nC\n      if ( is.na(tauL) | tauL == 0) tauL <- 0.5\n    }\n  }\n\n  # sender/receiver\n  if ( length(sender) == 2 ) sender <- NULL\n  if ( length(receiver) == 2 ) receiver <- NULL\n  if ( !is.null(sender) ) {\n    sender <- match.arg(sender, c(\"const\", \"var\"))\n    theta0 <- Rfast::colMaxs( colSums(aperm(Y, c(2,1,3)), na.rm = TRUE) )\n    if ( sender == \"const\" ){\n      tmp <- Y\n      tmp[which( tmp == 0)] <- 1\n      tmp[is.na(tmp)] <- 0\n      elegible <- rowSums( apply(tmp, 3, rowSums ) != 0) == K\n      pick <- which( elegible[theta0] == TRUE )[1]\n      theta0 <- rep(theta0[pick], K)\n    }\n  } else theta0 <- NULL\n  if ( !is.null(receiver) ) {\n    receiver <- match.arg(receiver, c(\"const\", \"var\"))\n    gamma0 <- Rfast::colMaxs( colSums(Y, na.rm = TRUE) )\n    if( receiver == \"const\" ){\n      tmp <- Y\n      tmp[which( tmp == 0)] <- 1\n      tmp[is.na(tmp)] <- 0\n      elegible <- rowSums( apply(tmp, 3, colSums ) != 0) == K\n      pick <- which( elegible[gamma0] == TRUE )[1]\n      gamma0 <- rep(gamma0[pick], K)\n    }\n  } else gamma0 <- NULL\n  noSendRec <- is.null(sender) & is.null(receiver)\n\n  # number of arcs for each view\n  arcSumY <- vapply( 1:K, function(k) sum(Y[,,k], na.rm = TRUE), double(1) )\n\n  # starting values -------------------------------------------------------------------\n  inZ <- startZ(Y, n, D, K)\n  inLogit <- startLogit(Y, K, inZ$distZ, alphaRef, noSendRec, ind)\n  theta <- startSend(Y, arcSumY, n, K, sender, theta0)\n  gamma <- startRec(Y, arcSumY, n, K, receiver, gamma0)\n  inLambda <- startLambda(covariates, nC)\n\n  # objects to be stored --------------------------------------------------------------\n  # nPar <- K - 1 + K - 1 + 4       # number of logit parameters\n  ALPHA <- BETA <- accALPHABETA <- matrix(NA, niter + 1, K - 1)\n  MSALPHA <- MSBETA <- accMSALPHA <- accMSBETA <-\n    matrix(NA, niter + 1, 2)   # muAlpha and sigmaAlpha - muBeta and sigmaBeta\n  ALPHA[1,] <- inLogit$alpha[2:K]\n  BETA[1,] <- inLogit$beta[2:K]\n  MSALPHA[1,] <- c(inLogit$muAlpha, inLogit$sigmaAlpha)\n  MSBETA[1,] <- c(inLogit$muBeta, inLogit$sigmaBeta)\n  Z <- array(NA, c(n, D, niter + 1))\n  Z[,,1] <- inZ$z\n  accZ <- matrix(NA, n, niter + 1)\n  #\n  meanThetaOld <- meanGammaOld <- varGammaOld <- varThetaOld <- NULL\n  if ( !is.null(sender) ) {\n    THETA <- accTHETA <- array(NA, c(n, K, niter + 1))\n    THETA[,,1] <- theta\n    meanThetaOld <- matrix(0, ncol = K, nrow = n)\n    varThetaOld <- matrix(1, ncol = K, nrow = n)\n  }\n  if ( !is.null(receiver) ) {\n    GAMMA <- accGAMMA <- array(NA, c(n, K, niter + 1))\n    GAMMA[,,1] <- gamma\n    meanGammaOld <- matrix(0, ncol = K, nrow = n)\n    varGammaOld <- matrix( 1, ncol = K, nrow = n)\n  }\n\n  if ( !is.null(covariates) ) {\n    # nC <- dim(covariates)[3]\n    LAMBDA <- accLAMBDA  <- MLAMBDA <- SLAMBDA <- matrix(NA, niter + 1, nC)\n  }\n\n  # correlation with reference latent space -- for simulated data experiments\n  corrZ <- if ( !is.null(refSpace) ) rep(NA, niter) else NULL\n\n\n  # MCMC ------------------------------------------------------------------------------\n  alpha <- inLogit$alpha[1:K]\n  beta <- inLogit$beta[1:K]\n  muAlpha <- inLogit$muAlpha                 # prior parameters\n  muBeta <- inLogit$muBeta\n  sigmaAlpha <- inLogit$sigmaAlpha\n  sigmaBeta <- inLogit$sigmaBeta\n  meanAlphaOld_k <- inLogit$meanAlphaOld_k   # proposal parameters\n  varAlphaOld_k <- inLogit$varAlphaOld_k\n  meanBetaOld_k <- inLogit$meanBetaOld_k\n  varBetaOld_k <- inLogit$varBetaOld_k\n  #\n  distZ <- inZ$distZ\n  z <- inZ$z\n  meanZOld_i <- inZ$MeanZOld_i\n  varZOld_i  <- inZ$VarZOld_i\n  #\n  if ( !is.null(covariates) ) {\n    lambda <- inLambda$lambda\n    muLambda_l <- inLambda$meanLambda_l     # prior parameters\n    sigmaLambda_l <- inLambda$varLambda_l\n    meanLambdaOld_l <- rep(0, nC)           # proposal parameters\n    varLambdaOld_l <- rep(1, nC)\n    #\n    # initialize sufficient stats for lambda\n    lambdaCov <- covariates * array( rep(lambda, each = nn), c(n, n, nC) )\n    # faster than lambdaCovSum <- apply(lambdaCov, 1:2, sum)\n    tmp1 <- c(lambdaCov)\n    tmp2 <- paste0(\"tmp1[\", (p-1)*(nn) + 1, \":\", p*nn, \"]\", collapse = \"+\")\n    lambdaCovSum <- matrix( eval(parse(text = tmp2)), n,n )\n  } else {\n    lambda <- inLambda$lambda\n    lambdaCov <- NULL\n    lambdaCovSum <- 0\n  }\n\n  gammaTheta <- 1\n\n  pbar <- txtProgressBar(min = 2, max = (niter+1), style = 3)\n  on.exit( close(pbar) )\n  for ( it in 2:(niter + 1) ) {\n    # if ( it%%10 == 0 ) showTrace(it)\n    setTxtProgressBar(pbar, it)\n\n    # sufficient stats for gamma and theta (only if they are in the model)\n    gt <- if ( is.null(sender) | is.null(receiver) ) 1 else 0.5\n    if ( !noSendRec ) {\n      gammaTheta <- list2array(\n        lapply(1:K, function(k) matrix(gamma[,k], n,n, byrow = TRUE) + theta[,k]) )*gt\n    }\n\n    ### alpha and beta parameters ...................................\n    # update sigmaAlpha\n    sigmaAlpha <- sigmaFc(alpha, muAlpha, nuA, tauA) * (n/5)\n    MSALPHA[it,2] <- sigmaAlpha\n    # update muAlpha\n    muAlpha <- muFc(alpha, sigmaAlpha, tauA, muA, boundA, Inf)\n    MSALPHA[it,1] <- muAlpha\n\n    # update sigmaBeta\n    sigmaBeta <- sigmaFc(beta, muBeta, nuB, tauB)\n    MSBETA[it,2] <- sigmaBeta\n    # update muBeta\n    muBeta <- muFc(beta, sigmaBeta, tauB, muB, 0, Inf)\n    MSBETA[it,1] <- muBeta\n\n    if ( !is.null(covariates) ) {\n      # update sigmaLambda_l\n      sigmaLambda_l <- vapply( 1:nC, function(l) sigmaFc(lambda[l], muLambda_l[l], nuL, tauL), numeric(1) )\n      SLAMBDA[it,] <- sigmaLambda_l\n      # update muLambda_l\n      muLambda_l <- vapply( 1:nC, function(l) muFc(lambda[l], sigmaLambda_l[l], tauL, muL, 0, Inf), numeric(1) )\n      MLAMBDA[it,] <- muLambda_l\n    }\n\n    # update alpha\n    alphaBetaCand <-\n      vapply( 2:K, function(k) {\n        alphaBetaProp_k(k, Y[,,k], n, arcSumY[k], alpha[k], beta[k],\n                        if (noSendRec) gammaTheta else gammaTheta[,,k], distZ,\n                        muAlpha, sigmaAlpha, muBeta, sigmaBeta,\n                        boundA, lambdaCovSum, ind[,,k], noSendRec)\n      }, numeric(6) )\n    alphaTry <- alphaBetaCand[1,]\n    alphaTryMean <- alphaBetaCand[2,]\n    alphaTryVar <- alphaBetaCand[3,]\n    betaTry <- alphaBetaCand[4,]\n    betaTryMean <- alphaBetaCand[5,]\n    betaTryVar <- alphaBetaCand[6,]\n    #\n    alphaOld <- alpha     # keep previous values\n    alphaNew <- alphaOld\n    betaOld <- beta\n    betaNew <- betaOld\n\n    # compute acceptance ratio\n    for ( k in 2:K ) {\n      # out <- vapply(2:K, function(k) {\n      alphaNew[k] <- alphaTry[k-1]\n      betaNew[k] <- betaTry[k-1]\n\n      logDiff <- logPosterior(Y, n, K, alphaNew, betaNew,\n                              muAlpha, sigmaAlpha, muBeta, sigmaBeta,\n                              muLambda_l, sigmaLambda_l,\n                              muA, tauA, nuA,\n                              muB, tauB, nuB,\n                              muL, tauL, nuL,\n                              gammaTheta, 0, lambda,\n                              z, distZ, lambdaCovSum,\n                              ind, term = \"alphaBeta\", noSendRec) -\n        logPosterior(Y, n, K, alphaOld, betaOld,\n                     muAlpha, sigmaAlpha, muBeta, sigmaBeta,\n                     muLambda_l, sigmaLambda_l,\n                     muA, tauA, nuA,\n                     muB, tauB, nuB,\n                     muL, tauL, nuL,\n                     gammaTheta, 0, lambda,\n                     z, distZ, lambdaCovSum,\n                     ind, term = \"alphaBeta\", noSendRec)\n\n      num <- c( RcppTN::dtn(alphaOld[k], .mean = alphaTryMean[k-1], .sd = sqrt(alphaTryVar[k-1]),\n                            .low = boundA, .checks = FALSE),\n                RcppTN::dtn(betaOld[k], .mean = betaTryMean[k-1], .sd = sqrt(betaTryVar[k-1]),\n                            .low = 0, .checks = FALSE)\n      )\n      den <- c( RcppTN::dtn(alphaNew[k], .mean = meanAlphaOld_k[k-1], .sd = sqrt(varAlphaOld_k[k-1]),\n                            .low = boundA, .checks = FALSE),\n                RcppTN::dtn(betaNew[k], .mean = meanBetaOld_k[k-1], .sd = sqrt(varBetaOld_k[k-1]),\n                            .low = 0, .checks = FALSE)\n      )\n\n      logAccAlphaBeta <- logDiff + ( sum( log(num) ) - sum( log(den) ) )\n      logU <- log( runif(1) )\n      if ( logAccAlphaBeta < logU | any(is.nan(num)) | any(is.infinite(num)) | any(num == 0) ) {\n        # reject\n        alphaNew[k] <- alphaOld[k]\n        betaNew[k] <- betaOld[k]\n        # accAlphaBeta <- 0\n        accALPHABETA[it,k-1] <- 0\n      } else {\n        # accept\n        alphaOld[k] <- alphaNew[k]\n        meanAlphaOld_k[k-1] <- alphaTryMean[k-1]\n        varAlphaOld_k[k-1] <- alphaTryVar[k-1]\n        betaOld[k] <- betaNew[k]\n        meanBetaOld_k[k-1] <- betaTryMean[k-1]\n        varBetaOld_k[k-1] <- betaTryVar[k-1]\n        # accAlphaBeta <- 1\n        accALPHABETA[it,k-1] <- 1\n      }\n      # return( matrix( c(alphaNew[k], meanAlphaOld_k[k-1], varAlphaOld_k[k-1],\n      #                   betaNew[k], meanBetaOld_k[k-1], varBetaOld_k[k-1], accAlphaBeta), 7, 1 ) )\n      # }, numeric(7))\n    }\n\n    alpha <- alphaOld\n    beta <- betaOld\n    #\n    ALPHA[it,] <- alpha[-1]\n    BETA[it,] <- beta[-1]\n    ###..............................................................\n\n    ###..............................................................\n    zOld <- z\n    distZOld <- distZ\n    for ( i in 1:n ) {\n      zProp <- zProp_i(i, Y[i,,], n, K, D, z, distZ[i,], alpha, beta,\n                       ind[i,,],  if (noSendRec) gammaTheta else gammaTheta[i,,],\n                       if ( length(lambdaCovSum) != 1 ) lambdaCovSum[i,] else 0)\n\n      zNew <- z\n      zNew[i,] <- zProp$zNew_i\n      distZNew <- Rfast::Dist(zNew, square = TRUE)\n\n      logDiff <- logPosterior(Y, n, K, alpha, beta,\n                              muAlpha, sigmaAlpha,\n                              muBeta, sigmaBeta,\n                              muLambda_l, sigmaLambda_l,\n                              muA, tauA, nuA,\n                              muB, tauB, nuB,\n                              muL, tauL, nuL,\n                              gammaTheta, 0, lambda,\n                              zNew, distZNew,\n                              lambdaCovSum,\n                              ind, term = \"z\", noSendRec) -\n        logPosterior(Y, n, K, alpha, beta,\n                     muAlpha, sigmaAlpha,\n                     muBeta, sigmaBeta,\n                     muLambda_l, sigmaLambda_l,\n                     muA, tauA, nuA,\n                     muB, tauB, nuB,\n                     muL, tauL, nuL,\n                     gammaTheta, 0, lambda,\n                     z, distZ,\n                     lambdaCovSum,\n                     ind, term = \"z\", noSendRec)\n\n      logAccZ <- logDiff +\n        ( Rfast::dmvnorm( z[i,], zProp$meanZ_i, diag(zProp$varZ_i, D), logged = TRUE ) -\n            Rfast::dmvnorm( zNew[i,], meanZOld_i[i,], diag(varZOld_i[i], D), logged = TRUE )\n        )\n      logU <- log( runif(1) )\n\n      if ( logAccZ >= logU ) {\n        z[i,] <- zProp$zNew_i\n        distZ <- distZNew\n        meanZOld_i[i,] <- zProp$meanZ_i\n        varZOld_i[i] <- zProp$varZ_i\n        accZ[i,it] <- 1\n      } else accZ[i,it] <- 0\n    }\n\n    ##--- check if the new set is just a rotation of the previous-----\n    rotCheck <- vegan::protest( z, zOld, scale = FALSE, translation = FALSE,\n                                permutations = permute::how(nperm = 99) )[[6]]\n    if ( rotCheck >= 0.95 ) {\n      z <- zOld\n      distZ <- distZOld\n    }\n    Z[,,it] <- z\n    ##-----------------------------------------------------------------\n\n    ##------correlation with a ref latent space------------------------\n    if ( !is.null(refSpace) ){\n      corrZ[it] <- vegan::protest( z, refSpace, scale = FALSE, translation = FALSE )[[6]]\n    }\n    ##-----------------------------------------------------------------\n    #close update only z\n\n    ###..............................................................\n    if( !noSendRec){\n      if(!is.null(sender)){\n        thetaOld <- theta\n        gammaThetaOld <- gammaTheta\n        for ( i in 1:n ) {\n          ##-----propose a new value for theta_i ---------------------------------\n          thetaProp <- gammaThetaProp_i(theta[i,], Y[i,,], n, K, distZ[i,],i,\n                                        alpha, beta, gt, gammaTheta[i,,], gamma,\n                                        if ( length(lambdaCovSum) != 1 ) lambdaCovSum[i,] else 0,\n                                        sender, theta0,\n                                        if ( !is.null(sender) ) meanThetaOld[i,] else 0,\n                                        if ( !is.null(sender) ) varThetaOld[i,] else 0,\n                                        ind[i,,]\n          )  ##effect is either N or C or V\n          thetaNew <- theta\n          thetaNew[i, ] <- thetaProp$parProp\n\n          gammaThetaNew <- list2array(\n            lapply(1:K, function(k) matrix(gamma[,k], n,n, byrow = TRUE) + thetaNew[,k]) )*gt\n\n          logDiff <- logPosterior(Y, n, K, alpha, beta,\n                                  muAlpha, sigmaAlpha,\n                                  muBeta, sigmaBeta,\n                                  muLambda_l, sigmaLambda_l,\n                                  muA, tauA, nuA,\n                                  muB, tauB, nuB,\n                                  muL, tauL, nuL,\n                                  gammaThetaNew,0, lambda,\n                                  z, distZ,\n                                  lambdaCovSum,\n                                  ind, term = \"sendRec\", noSendRec) -\n            logPosterior(Y, n, K, alpha, beta,\n                         muAlpha, sigmaAlpha,\n                         muBeta, sigmaBeta,\n                         muLambda_l, sigmaLambda_l,\n                         muA, tauA, nuA,\n                         muB, tauB, nuB,\n                         muL, tauL, nuL,\n                         gammaTheta, 0, lambda,\n                         z, distZ,\n                         lambdaCovSum,\n                         ind, term =\"sendRec\", noSendRec)\n\n          logAccTheta <-  logDiff + thetaProp$accRatio\n\n          logU <- log( runif(1) )\n\n          if ( logAccTheta >= logU & !is.na(logAccTheta) ) {\n            gammaTheta <- gammaThetaNew\n            theta[i, ] <- thetaNew[i, ]\n            meanThetaOld[i,] <- thetaProp$muProp\n            varThetaOld[i,] <- thetaProp$varProp\n            accTHETA[i,,it] <- rep(1, K)\n          } else{\n            accTHETA[i,,it] <- rep(0, K)\n          }\n        } # end i loop\n\n        if ( !is.null(receiver) ) {\n          checkTheta <- sapply( 1:K, function(x)\n            cor( c(alphaRef, ALPHA[it-1,])[x]*c(gammaThetaOld[,,x]),\n                 alpha[x]*c(gammaTheta[,,x]), use = \"na.or.complete\" )\n          ) }\n        else{ checkTheta <- sapply(1:K, function(x)\n          cor( c(alphaRef, ALPHA[it-1,])[x] *c(thetaOld[,x]),\n               alpha[x]*c(theta[,x]), use = \"na.or.complete\" )\n        ) }\n        subs <- which( abs(checkTheta) - boundGammaTheta > 0)\n\n        if(length( subs) >0){\n          theta[,subs] <- thetaOld[,subs]\n          gammaTheta[,,subs] <- gammaThetaOld[,,subs]\n        }\n        THETA[,,it] <- theta\n      }\n\n\n      if(!is.null(receiver)){\n        gammaOld <- gamma\n        gammaThetaOld <- gammaTheta\n        for ( i in 1:n ) {\n          ##-----propose a new value for gamma_i ---------------------------------\n          gammaProp <- gammaThetaProp_i(gamma[i,], Y[,i,], n, K, distZ[i,],i, # gamma\n                                        alpha, beta, gt, gammaTheta[,i,], theta,\n                                        if ( length(lambdaCovSum) != 1 ) lambdaCovSum[,i] else 0,\n                                        receiver, gamma0,\n                                        if ( !is.null(receiver) ) meanGammaOld[i,] else 0,\n                                        if ( !is.null(receiver) ) varGammaOld[i,] else 0,\n                                        ind[,i,]\n          )  # effect is either N or C or V\n          gammaNew <- gamma\n          gammaNew[i, ] <- gammaProp$parProp\n\n          gammaThetaNew <- list2array(\n            lapply(1:K, function(k) matrix(gammaNew[,k], n,n, byrow = TRUE) + theta[,k]) )*gt\n\n          logDiff <- logPosterior(Y, n, K, alpha, beta,\n                                  muAlpha, sigmaAlpha,\n                                  muBeta, sigmaBeta,\n                                  muLambda_l, sigmaLambda_l,\n                                  muA, tauA, nuA,\n                                  muB, tauB, nuB,\n                                  muL, tauL, nuL,\n                                  gammaThetaNew,0, lambda,\n                                  z, distZ,\n                                  lambdaCovSum,\n                                  ind, term = \"sendRec\", noSendRec) -\n            logPosterior(Y, n, K, alpha, beta,\n                         muAlpha, sigmaAlpha,\n                         muBeta, sigmaBeta,\n                         muLambda_l, sigmaLambda_l,\n                         muA, tauA, nuA,\n                         muB, tauB, nuB,\n                         muL, tauL, nuL,\n                         gammaTheta, 0, lambda,\n                         z, distZ,\n                         lambdaCovSum,\n                         ind, term =\"sendRec\", noSendRec)\n\n          logAccGamma <-  logDiff + gammaProp$accRatio\n          logU <- log( runif(1) )\n\n          if ( logAccGamma >= logU & !is.na(logAccGamma) ) {\n            gammaTheta <- gammaThetaNew\n            gamma[i, ] <- gammaNew[i, ]\n            meanGammaOld[i,] <- gammaProp$muProp\n            varGammaOld[i,] <- gammaProp$varProp\n            accGAMMA[i,,it] <- rep(1, K)\n          } else{\n            accGAMMA[i,,it] <- rep(0, K)\n          }\n        } # end i loop\n\n        if ( !is.null(sender) ) {\n          checkGamma <- sapply(1:K, function(x)\n            cor( c(alphaRef, ALPHA[it-1,])[x]*c(gammaThetaOld[,,x]),\n                 alpha[x]*c(gammaTheta[,,x]), use = \"na.or.complete\" ))\n        } else { checkGamma <- sapply(1:K, function(x)\n          cor( c(alphaRef, ALPHA[it-1,])[x] *c(gammaOld[,x]),\n               alpha[x]*c(gamma[,x]), use = \"na.or.complete\" ))\n        }\n        subs <- which( abs(checkGamma) - boundGammaTheta > 0)\n\n        if( length(subs) > 0 ){\n          gamma[,subs] <- gammaOld[,subs]\n          gammaTheta[,,subs] <- gammaThetaOld[,,subs]\n        }\n        GAMMA[,,it] <- gamma\n      }\n    } # close update sender and receiver\n    ###..............................................................\n\n    ### lambda ......................................................\n    if ( !is.null(covariates) ) {\n      out <- vapply(1:nC, function(l) {\n        lambdaProp_l(l, Y, n, K, nC, lambdaCov, lambdaCovSum, muLambda_l, sigmaLambda_l,\n                     alpha, beta, noSendRec, gammaTheta, distZ, ind)\n      }, numeric(3))\n\n      lambdaTry <- out[1,]\n      lambdaTryMean <- out[2,]\n      lambdaTryVar <- out[3,]\n      lambdaOld <- lambda\n      lambdaNew <- lambdaOld\n      lambdaCovOld <- lambdaCov\n      lambdaCovSumOld <- lambdaCovSum\n\n\n      for( l in 1:nC ){\n        lambdaNew[l] <- lambdaTry[l]\n\n        # update sufficient statistics\n        lambdaCovNew <- covariates * array( rep(lambdaNew, each = nn), c(n, n, nC) )\n        tmp1 <- c(lambdaCovNew)\n        tmp2 <- paste0(\"tmp1[\", (p-1)*(nn) + 1, \":\", p*nn, \"]\", collapse = \"+\")\n        lambdaCovSumNew <- matrix( eval(parse(text = tmp2)), n,n )\n\n        logDiff <- logPosterior(Y, n, K, alpha, beta,\n                                muAlpha, sigmaAlpha, muBeta, sigmaBeta,\n                                muLambda_l, sigmaLambda_l,\n                                muA, tauA, nuA,\n                                muB, tauB, nuB,\n                                muL, tauL, nuL,\n                                gammaTheta, 0, lambdaNew,\n                                z, distZ, lambdaCovSumNew,\n                                ind, term = \"lambda\", noSendRec) -\n          logPosterior(Y, n, K, alpha, beta,\n                       muAlpha, sigmaAlpha, muBeta, sigmaBeta,\n                       muLambda_l, sigmaLambda_l,\n                       muA, tauA, nuA,\n                       muB, tauB, nuB,\n                       muL, tauL, nuL,\n                       gammaTheta, 0, lambdaOld,\n                       z, distZ, lambdaCovSumOld,\n                       ind, term = \"lambda\", noSendRec)\n\n        num <- RcppTN::dtn(lambdaOld[l], .mean = lambdaTryMean[l], .sd = sqrt(lambdaTryVar[l]),\n                           .low = 0, .checks = FALSE)\n        den <- RcppTN::dtn(lambdaNew[l], .mean = meanLambdaOld_l[l], .sd = sqrt(varLambdaOld_l[l]),\n                           .low = 0, .checks = FALSE)\n\n        logLambda <- logDiff + ( log(num) - log(den) )\n        logU <- log( runif(1) )\n        if ( logLambda < logU | any(is.nan(num)) | any(is.infinite(num)) | any(num == 0) ) {\n          # reject\n          lambdaNew[l] <- lambdaOld[l]\n          accLAMBDA[it,l] <- 0\n        } else {\n          # accept\n          lambdaOld[l] <- lambdaNew[l]\n          meanLambdaOld_l[l] <- lambdaTryMean[l]\n          varLambdaOld_l[l] <- lambdaTryVar[l]\n          accLAMBDA[it,l] <- 1\n          lambdaCovSumOld <- lambdaCovSumNew\n          lambdaCovOld <- lambdaCovNew\n        }\n      }\n      lambdaCovSum <- lambdaCovSumOld\n      lambda <- lambdaOld\n      lambdaCov <- lambdaCovOld\n      LAMBDA[it,] <- lambda\n    }\n    ###..............................................................\n\n    # compute first part DIC\n    if( DIC ){\n      dBar[it-1] <- -2*loglik(Y, n, K, alpha, beta,\n                              gammaTheta, distZ,\n                              lambdaCovSum,ind,\n                              noSendRec)\n    }\n  } # mcmc loop\n\n  # output of the chain\n  set <- (burnIn + 2):(niter + 1)\n  ALPHA_mean <- colMeans( ALPHA[set, ])\n  ALPHA_sd <- apply( ALPHA[set, ], 2, sd)\n  BETA_mean <- colMeans( BETA[set, ])\n  BETA_sd <- apply( BETA[set, ], 2, sd)\n  accALPHABETA_rate <- colSums(accALPHABETA[set,])/(niter -burnIn -2)\n  #### accALPHABETA\n\n  accZ_rate <- rowSums( accZ[,set] )/(niter -burnIn -2)\n  Z_mean <- apply(Z[,,set], c(1,2), mean)\n  Z_sd <- apply(Z[,,set], c(1,2), sd)\n  distZ_mean <- as.matrix( dist( Z_mean )^2 )\n\n  if( !is.null(receiver) ) {\n    GAMMA_mean <- apply( GAMMA[,,set], c(1,2), mean)\n    GAMMA_sd <- apply( GAMMA[,,set], c(1,2), sd)\n    accGAMMA_rate <- apply(accGAMMA[,,set], c(1,2), sum)/(niter -burnIn -2)\n  } else GAMMA_mean <- gamma\n  if( !is.null(sender) ){\n    THETA_mean <- apply( THETA[,,set], c(1,2), mean)\n    THETA_sd <- apply( THETA[,,set], c(1,2), sd)\n    accTHETA_rate <- apply( accTHETA[,,set], c(1,2), sum )/(niter -burnIn -2)\n  } else THETA_mean <- theta\n  if( !noSendRec ) {\n    gammaTheta_mean <- list2array(\n      lapply(1:K, function(k) matrix(GAMMA_mean[,k], n,n, byrow = TRUE) + THETA_mean[,k]) )*gt\n  } else gammaTheta_mean <- 1\n\n  if( !is.null(covariates) ){\n    accLAMBDA_rate <- colSums(accLAMBDA[set,,drop = FALSE])/(niter -burnIn -2)\n    LAMBDA_mean <- colMeans(LAMBDA[set,,drop = FALSE])\n    LAMBDA_sd <- apply( ALPHA[set,,drop = FALSE], 2, sd )\n    lambdaCov_mean <- covariates * array( rep(LAMBDA_mean, each = nn), c(n, n, nC) )\n    tmp1 <- c(lambdaCov_mean)\n    tmp2 <- paste0(\"tmp1[\", (p-1)*(nn) + 1, \":\", p*nn, \"]\", collapse = \"+\")\n    lambdaCovSum_mean <- matrix( eval(parse(text = tmp2)), n,n )\n  } else lambdaCovSum_mean <- lambdaCovSum\n\n\n  # todo: lambda cov sum mean\n  if ( DIC ){\n    dHat <- -2*loglik(Y, n, K, c(alphaRef, ALPHA_mean), c(1, BETA_mean),\n                      gammaTheta_mean, distZ_mean,\n                      lambdaCovSum_mean, ind,\n                      noSendRec)\n    dBar <- mean( dBar[(burnIn+1):niter] )\n    DIC <- dHat + 2*( dBar - dHat )\n  }\n\n  # prepare output\n  parameters <- list(alpha = list(mean = c(alphaRef, ALPHA_mean), sd = c(0, ALPHA_sd)),\n                     beta = list(mean = c(1, BETA_mean), sd = c(0, BETA_sd)),\n                     gamma = if ( !is.null(receiver) ) {\n                       list(mean = GAMMA_mean, sd = GAMMA_sd) } else (list(mean = NULL, sd = NULL)),\n                     theta = if ( !is.null(sender) ) {\n                       list(mean = THETA_mean, sd = THETA_sd) } else (list(mean = NULL, sd = NULL)),\n                     lambda = if ( !is.null(covariates) ) {\n                       list(mean = LAMBDA_mean, sd = LAMBDA_sd) } else (list(mean = NULL, sd = NULL))\n  )\n  latPos <- list(mean = Z_mean, sd = Z_sd)\n  accRates <- list(alpha = accALPHABETA_rate[1], beta = accALPHABETA_rate[2],\n                   gamma = if (!is.null(receiver)) accGAMMA_rate else NULL,\n                   theta = if (!is.null(sender)) accTHETA_rate else NULL,\n                   lambda = if (!is.null(covariates)) accLAMBDA_rate else NULL,\n                   latPos = accZ_rate)\n  if ( allChains ) {\n    allChains <- list(parameters = list(\n      alpha = cbind(alphaRef, ALPHA[2:(niter+1),]), beta = cbind(1, BETA[2:(niter+1),]),\n      gamma = if (!is.null(receiver)) GAMMA[,,2:(niter+1)] else NULL,\n      theta = if (!is.null(sender)) THETA[,,2:(niter+1)] else NULL,\n      lambda = if (!is.null(covariates)) LAMBDA[2:(niter+1),] else NULL),\n      latPos = Z[,,2:(niter+1)],\n      priorParameters = list(\n        alphaPrior = MSALPHA, betaPrior = MSBETA,\n        lambdaPrior = if (!is.null(covariates)) list(meanLambda = MLAMBDA, sdLambda = SLAMBDA) else NULL\n      )\n      # , accept = list(alpha = accALPHABETA[2:(niter+1),1], beta = accALPHABETA[2:(niter+1),2],\n      #               gamma = if (!is.null(receiver)) accGAMMA[,,2:(niter+1)] else NULL,\n      #               theta = if (!is.null(sender)) THETA[,,2:(niter+1)] else NULL,\n      #               lambda = if (!is.null(covariates)) LAMBDA[2:(niter+1),] else NULL,\n      #               latPos = accZ[,2:(niter+1)])\n    )\n  } else allChains <- NULL\n\n  if ( !is.numeric(DIC) ) DIC <- NULL\n  out <- list(n = n, K = K, D = D, parameters = parameters,\n              latPos = latPos, accRates = accRates,\n              DIC = DIC, allChains = allChains, corrRefSpace = corrZ,\n              info = list(call = call, niter = niter, burnIn = burnIn,\n                          # receiver = receiver, sender = sender,\n                          covariates = if( !is.null(covariates) ) TRUE else FALSE,\n                          L = nC)\n  )\n  class(out) <- \"multiNet\"\n  return(out)\n}\n\n\nprint.multiNet <- function(x, ...)\n{\n  alpha <- x$parameters$alpha$mean\n  beta <- x$parameters$beta$mean\n  # gamma <- x$parameters$gamma$mean\n  # theta <- x$parameters$theta$mean\n  lambda <- x$parameters$lambda$mean\n  dic <- x$DIC\n  nC <- x$info$nC\n\n  if ( is.null(nC) ) {\n    h1 <- paste(x$D, \"dimensional latent space model\")\n    h2 <- \"    for multivariate networks\"\n    sep <- paste0( rep(\"=\", max(nchar(h1), nchar(h2)) + 5), collapse = \"\" )\n    cat(\"\\n\", sep, \"\\n\")\n    cat(\"  \", h1, \"\\n\")\n    cat(\"  \", h2, \"\\n\")\n    cat(\"\", sep, \"\\n\", \"\\n\")\n    cat(\" View 1\", \" --- \", \"P(y = 1) =\", round(alpha[1], 2), \"- 1.00*dZ\", \"\\n\")\n    for ( k in 2:x$K ) {\n      cat(\" View\", k, \" --- \", \"P(y = 1) =\", round(alpha[k], 2), \"-\",\n          paste(round(beta[k], 2), \"dZ\", sep = \"*\"), \"\\n\")\n    }\n  } else {\n    covs <- paste0(\"X\", 1:x$info$nC)\n    h1 <- paste(\"    \", x$D, \"dimensional latent space model\")\n    h2 <- \"for multivariate networks, with covariates\"\n    sep <- paste0( rep(\"=\", max(nchar(h1), nchar(h2)) + 5), collapse = \"\" )\n    cat(\"\\n\", sep, \"\\n\")\n    cat(\"  \", h1, \"\\n\")\n    cat(\"  \", h2, \"\\n\")\n    cat(\"\", sep, \"\\n\", \"\\n\")\n    cat(\" View 1\", \" --- \", \"P(y = 1) =\", round(alpha[1], 2), \"- 1.00*dZ\", \"-\",\n        paste(paste(round(lambda, 2), covs, sep = \"*\"), collapse = \" - \"), \"\\n\" )\n    for ( k in 2:x$K ) {\n      cat(\" View\", k, \" --- \", \"P(y = 1) =\", round(alpha[k], 2), \"-\",\n          paste(round(beta[k], 2), \"dZ\", sep = \"*\"),\"-\",\n          paste(paste(round(lambda, 2), covs, sep = \"*\"), collapse = \" - \"),\n          \"\\n\")\n    }\n  }\n  if ( !is.null(dic) ) cat(\"\\n\", \"DIC = \", dic, \"\\n\")\n  cat(\"\\n\")\n}\n",
    "created" : 1520243125745.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2252888213",
    "id" : "878E3EFE",
    "lastKnownWriteTime" : 1520593789,
    "last_content_update" : 1520593789,
    "path" : "C:/Users/Silvia/Downloads/spaceNet/spaceNet/R/multiNet.R",
    "project_path" : "R/multiNet.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}